{-
   Todo

   Todo

   OpenAPI Version: 3.0.3
   Todo API version: 1.0.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Todo.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Todo.Model where

import Todo.Core
import Todo.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** TodoId
newtype TodoId = TodoId { unTodoId :: Int } deriving (P.Eq, P.Show)

-- ** UserId
newtype UserId = UserId { unUserId :: Int } deriving (P.Eq, P.Show)

-- * Models


-- ** CreateTodoRequest
-- | CreateTodoRequest
data CreateTodoRequest = CreateTodoRequest
  { createTodoRequestTitle :: !(Text) -- ^ /Required/ "title"
  , createTodoRequestDescription :: !(Maybe Text) -- ^ "description"
  , createTodoRequestDueDate :: !(Maybe Date) -- ^ "due_date"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTodoRequest
instance A.FromJSON CreateTodoRequest where
  parseJSON = A.withObject "CreateTodoRequest" $ \o ->
    CreateTodoRequest
      <$> (o .:  "title")
      <*> (o .:? "description")
      <*> (o .:? "due_date")

-- | ToJSON CreateTodoRequest
instance A.ToJSON CreateTodoRequest where
  toJSON CreateTodoRequest {..} =
   _omitNulls
      [ "title" .= createTodoRequestTitle
      , "description" .= createTodoRequestDescription
      , "due_date" .= createTodoRequestDueDate
      ]


-- | Construct a value of type 'CreateTodoRequest' (by applying it's required fields, if any)
mkCreateTodoRequest
  :: Text -- ^ 'createTodoRequestTitle' 
  -> CreateTodoRequest
mkCreateTodoRequest createTodoRequestTitle =
  CreateTodoRequest
  { createTodoRequestTitle
  , createTodoRequestDescription = Nothing
  , createTodoRequestDueDate = Nothing
  }

-- ** CreateUserRequest
-- | CreateUserRequest
data CreateUserRequest = CreateUserRequest
  { createUserRequestName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateUserRequest
instance A.FromJSON CreateUserRequest where
  parseJSON = A.withObject "CreateUserRequest" $ \o ->
    CreateUserRequest
      <$> (o .:  "name")

-- | ToJSON CreateUserRequest
instance A.ToJSON CreateUserRequest where
  toJSON CreateUserRequest {..} =
   _omitNulls
      [ "name" .= createUserRequestName
      ]


-- | Construct a value of type 'CreateUserRequest' (by applying it's required fields, if any)
mkCreateUserRequest
  :: Text -- ^ 'createUserRequestName' 
  -> CreateUserRequest
mkCreateUserRequest createUserRequestName =
  CreateUserRequest
  { createUserRequestName
  }

-- ** Todo
-- | Todo
data Todo = Todo
  { todoId :: !(Maybe Int) -- ^ "id"
  , todoTitle :: !(Maybe Text) -- ^ "title"
  , todoDescription :: !(Maybe Text) -- ^ "description"
  , todoDueDate :: !(Maybe Date) -- ^ "due_date"
  , todoCreatedBy :: !(Maybe Int) -- ^ "created_by"
  , todoCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , todoUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Todo
instance A.FromJSON Todo where
  parseJSON = A.withObject "Todo" $ \o ->
    Todo
      <$> (o .:? "id")
      <*> (o .:? "title")
      <*> (o .:? "description")
      <*> (o .:? "due_date")
      <*> (o .:? "created_by")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")

-- | ToJSON Todo
instance A.ToJSON Todo where
  toJSON Todo {..} =
   _omitNulls
      [ "id" .= todoId
      , "title" .= todoTitle
      , "description" .= todoDescription
      , "due_date" .= todoDueDate
      , "created_by" .= todoCreatedBy
      , "created_at" .= todoCreatedAt
      , "updated_at" .= todoUpdatedAt
      ]


-- | Construct a value of type 'Todo' (by applying it's required fields, if any)
mkTodo
  :: Todo
mkTodo =
  Todo
  { todoId = Nothing
  , todoTitle = Nothing
  , todoDescription = Nothing
  , todoDueDate = Nothing
  , todoCreatedBy = Nothing
  , todoCreatedAt = Nothing
  , todoUpdatedAt = Nothing
  }

-- ** User
-- | User
data User = User
  { userId :: !(Maybe Int) -- ^ "id"
  , userName :: !(Maybe Text) -- ^ "name"
  , userTodos :: !(Maybe Todo) -- ^ "todos"
  , userCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , userUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON User
instance A.FromJSON User where
  parseJSON = A.withObject "User" $ \o ->
    User
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "todos")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")

-- | ToJSON User
instance A.ToJSON User where
  toJSON User {..} =
   _omitNulls
      [ "id" .= userId
      , "name" .= userName
      , "todos" .= userTodos
      , "created_at" .= userCreatedAt
      , "updated_at" .= userUpdatedAt
      ]


-- | Construct a value of type 'User' (by applying it's required fields, if any)
mkUser
  :: User
mkUser =
  User
  { userId = Nothing
  , userName = Nothing
  , userTodos = Nothing
  , userCreatedAt = Nothing
  , userUpdatedAt = Nothing
  }




-- * Auth Methods

-- ** AuthBasicBasicAuth
data AuthBasicBasicAuth =
  AuthBasicBasicAuth B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicBasicAuth where
  applyAuthMethod _ a@(AuthBasicBasicAuth user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])


